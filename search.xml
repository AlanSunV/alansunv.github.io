<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue2的响应式原理</title>
    <url>/2021/09/08/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>源码笔记一</title>
    <url>/2021/09/08/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1/</url>
    <content><![CDATA[<ol>
<li><p>Vue的引入<br>Vue的使用按照官方的说法支持CDN和NPM两种方式，CDN的方式是以script的方式将打包好的vue.js引入页面脚本中，而NPM的方式是和诸如 webpack 或 Browserify 模块打包器配置使用，以npm install vue的方式引入，这也是我们开发应用的主要形式。而从单纯分析源码思路和实现细节的角度来讲，打包后的vue.js在分析和提炼源码方面会更加方便，所以这个系列的源码分析，使用的是打包后的vue脚本</p>
</li>
<li><p>Vue的构造器，vue尊从umd规范  是commonjs和amd的整个，vue本身是一个构造器，保证它只能通过new实例的形式去调用，而不能通过函数形式去调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, factory</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 遵循UMD规范</span></span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="built_in">module</span>.exports = factory() :</span><br><span class="line">      <span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd ? define(factory) :</span><br><span class="line">      (<span class="built_in">global</span> = <span class="built_in">global</span> || self, <span class="built_in">global</span>.Vue = factory());</span><br><span class="line">    &#125;(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">      ···</span><br><span class="line">      <span class="comment">// Vue 构造函数</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 保证了无法直接通过Vue()去调用，只能通过new的方式去创建实例</span></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">        ) &#123;</span><br><span class="line">          warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._init(options);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Vue</span><br><span class="line">    &#125;)</span><br><span class="line">   <span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 定义原型属性方法</span><br><span class="line">  <span class="string">``</span><span class="string">` javascript</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  initMixin(Vue);// 定义Vue原型上的init方法(内部方法)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  stateMixin(Vue); // 定义原型上跟数据相关的属性方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  eventsMixin(Vue);//定义原型上跟事件相关的属性方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  lifecycleMixin(Vue);// 定义原型上跟生命周期相关的方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  renderMixin(Vue);  // 定义渲染相关的函数</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>  initMixin定义了内部在实例化Vue时会执行的初始化代码，它是一个内部使用的方法。<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  stateMixin方法会定义跟数据相关的属性方法，例如代理数据的访问，我们可以在实例上通过this.$data和this.$props访问到data,props的值，并且也定义了使用频率较高的this.$set,this.$delte等方法。</p>
]]></content>
  </entry>
  <entry>
    <title>web Worker</title>
    <url>/2021/09/08/JavaScript-web-worker/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2021/09/08/JavaScript-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript的原型与原型链</title>
    <url>/2021/09/08/JavaScript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>深浅拷贝</title>
    <url>/2021/09/08/JavaScript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2021/09/08/JavaScript-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>1.作用域：用于确定在何处以及如何查找变量的一套规则。</p>
<p>2.词法作用域：词法作用域是定义在词法阶段的作用域，词法作用域是由写代码时将代码和块作用域写在哪里来决定的，因此当词法作用域处理代码是会保持作用域不变。</p>
<p>3.块作用域：指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块，常见的块级作用域有with，try/catch，let，const等。</p>
<p>4.函数作用域：属于这个函数的全部变量都可以在整个函数范围内使用及复用。</p>
<p>5.作用域链：查找变量时，先从当前作用域开始查找，如果没找到，就会到父级进行查找，一直到全局作用域，作用域链正是包含这些作用域的列表。</p>
<h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><p>能够在函数定义的作用域外，访问函数作用域内的局部变量，并且不会污染全局变量。</p>
<p>基于词法作用域链和垃圾回收机制，通过维持函数作用域的引用，让函数作用域可以在当前作用域外进行访问。</p>
<h4 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h4><p>IIFE，立即调用的自执行函数<br>利用的优势：可立即执行，并且这种机制不会污染全局对象</p>
<p>方法的封装，通过闭包的形式访问变量，避免了全局变量的污染。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//变量作用域为函数内部，外部无法访问  </span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;default&quot;</span>;     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">       <span class="attr">getName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">           <span class="keyword">return</span> name;  </span><br><span class="line">       &#125;,  </span><br><span class="line">       <span class="attr">setName</span> : <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;  </span><br><span class="line">           name = newName;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;();  </span><br><span class="line">   </span><br><span class="line">print(person.name);<span class="comment">//直接访问，结果为undefined  </span></span><br><span class="line">print(person.getName());  </span><br><span class="line">person.setName(<span class="string">&quot;abruzzi&quot;</span>);  </span><br><span class="line">print(person.getName());  </span><br><span class="line"> </span><br><span class="line">得到结果如下：</span><br><span class="line"> </span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line">abruzzi</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>用来缓存数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CachedSearchBox = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;,  </span><br><span class="line">       count = [];  </span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">       <span class="attr">attachSearchBox</span> : <span class="function"><span class="keyword">function</span>(<span class="params">dsid</span>)</span>&#123;  </span><br><span class="line">           <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;<span class="comment">//如果结果在缓存中  </span></span><br><span class="line">              <span class="keyword">return</span> cache[dsid];<span class="comment">//直接返回缓存中的对象  </span></span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">var</span> fsb = <span class="keyword">new</span> uikit.webctrl.SearchBox(dsid);<span class="comment">//新建  </span></span><br><span class="line">           cache[dsid] = fsb;<span class="comment">//更新缓存  </span></span><br><span class="line">           <span class="keyword">if</span>(count.length &gt; <span class="number">100</span>)&#123;<span class="comment">//保正缓存的大小&lt;=100  </span></span><br><span class="line">              <span class="keyword">delete</span> cache[count.shift()];  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">return</span> fsb;        </span><br><span class="line">       &#125;,  </span><br><span class="line">   </span><br><span class="line">       <span class="attr">clearSearchBox</span> : <span class="function"><span class="keyword">function</span>(<span class="params">dsid</span>)</span>&#123;  </span><br><span class="line">           <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;  </span><br><span class="line">              cache[dsid].clearSelection();    </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;)();  </span><br><span class="line">   </span><br><span class="line">CachedSearchBox.attachSearchBox(<span class="string">&quot;input1&quot;</span>); </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>具体使用场景<br>实现防抖</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(self, args);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>EventLoop</title>
    <url>/2021/09/08/JavaScript-Event-Loop/</url>
    <content><![CDATA[<h1 id="Event-Loop（事件循环）"><a href="#Event-Loop（事件循环）" class="headerlink" title="Event Loop（事件循环）"></a>Event Loop（事件循环）</h1><h2 id="1-javascript是单线程的，非阻塞的"><a href="#1-javascript是单线程的，非阻塞的" class="headerlink" title="1.javascript是单线程的，非阻塞的"></a>1.javascript是单线程的，非阻塞的</h2><p>为什么js是单线程的？</p>
<p>JS的主要作用是与用户进行交互，以及操作dom。假如js为多线程的，现在有两个线程需要同时操作dom，一个线程把节点删除了，另一个线程要去操作这个dom，这个时候该以哪个线程为准呢？<br>所以JS是单线程的，以避免这种事情的发生。<br>但是JS也可以开启子线程的  web worker, 但是有很多限制，子线程受主线程的控制的。<br>所有的新线程都完全受主线程控制，无法单独执行。<br>也就是新的线程只是主线程的子线程<br>这些新的线程是没有执行I/O的操作权限的，只能为主线称分担一些计算任务，所以这些线程没有完整的功能不能算是真正的新线程。</p>
<p>非阻塞<br>通过eventLoop来实现js的非阻塞</p>
<h2 id="2-浏览器的事件循环"><a href="#2-浏览器的事件循环" class="headerlink" title="2.浏览器的事件循环"></a>2.浏览器的事件循环</h2><p>JS在异步代码的执行过程中，不会一直等待异步事件的返回结果，而是将异步事件进行挂起，继续执行栈中的其他任务。<br>当异步事件返回结果时，将它放到事件队列中，<br>被放入事件队列的后并不会立即执行，而是等待当前执行栈中所有的任务执行完成后，主线程处于空闲状态的时候，去查找事件队列中是否有任务，如果有，会取出排在第一位的事件，<br>并把这个事件对应的回调放到执行栈中，然后执行同步代码。</p>
<h2 id="3-宏任务和微任务"><a href="#3-宏任务和微任务" class="headerlink" title="3.宏任务和微任务"></a>3.宏任务和微任务</h2><p>为什么要有微任务？</p>
<p>页面渲染事件，IO的完成事件等等 都会随时加入到任务队列中，队列的规则是先进先出，不能准确的控制这些事件添加到队列的位置。<br>如果突然有高优先级的任务需要执行，只有一种任务类型就不满足了，所以有了微任务队列</p>
<p>node环境下的事件循环<br>node 环境中时间循环依赖libuv引擎<br>node10版本之前，微任务会在事件循环的各个阶段之间执行，一个阶段执行完毕后才会去执行微任务队列<br>node10版本之后，变得和浏览器一致，在执行一个宏任务之后就会立即执行所有的微任务</p>
<p>   ┌───────────────────────┐<br>┌─&gt;│        timers         │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     I/O callbacks     │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     idle, prepare     │<br>│  └──────────┬────────────┘      ┌───────────────┐<br>│  ┌──────────┴────────────┐      │   incoming:   │<br>│  │         poll          │&lt;──connections───     │<br>│  └──────────┬────────────┘      │   data, etc.  │<br>│  ┌──────────┴────────────┐      └───────────────┘<br>│  │        check          │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>└──┤    close callbacks    │<br>   └───────────────────────┘</p>
<p>Node时间循环的各个阶段</p>
<p>1.定时器检测阶段(timers): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。<br>2.I/O事件回调阶段(I/O callbacks): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。<br>3.闲置阶段(idle, prepare): 这个阶段仅在内部使用，可以不必理会<br>4.轮询阶段(poll): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。<br>5.检查阶段(check): setImmediate()的回调会在这个阶段执行。<br>6.关闭事件回调阶段(close callbacks): 例如socket.on(‘close’, …)这种close事件的回调</p>
<p>宏任务：<br>setImmediate<br>setTimeout<br>setInterval<br>script（整体代码)<br>I/O 操作等。</p>
<p>微任务：<br>process.nextTick<br>new Promise().then(回调)</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/09/07/JavaScript-demo/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    const a = 1;
    let b = 2;
    var c = 3;
    {
      var d = 4;
      const e = 5;
      {
        const f = 6;
      }
    }



    class aaaaa {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }

      toString() {
        return '(' + this.x + ', ' + this.y + ')';
      }
    }
    let aaaSub = new aaaaa(1, 2);
    debugger;

  </script>
</body>

</html>]]></content>
  </entry>
  <entry>
    <title>ES6、7、8</title>
    <url>/2021/09/08/JavaScript-es6-7-8/</url>
    <content><![CDATA[<p>proxy<br>（<a href="https://es6.ruanyifeng.com/#docs/proxy%EF%BC%89">https://es6.ruanyifeng.com/#docs/proxy）</a></p>
<p><a href="https://github.com/XiaoDHuang/node_index/issues/11">https://github.com/XiaoDHuang/node_index/issues/11</a>   （JavaScript执行系统之环境）为什么全局对象（global）上访问不到let，const声明的变量</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript的异步</title>
    <url>/2021/09/08/JavaScript-%E5%89%8D%E7%AB%AF%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="一、回调函数（callBack）"><a href="#一、回调函数（callBack）" class="headerlink" title="一、回调函数（callBack）"></a>一、回调函数（callBack）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//callback的函数体</span></span><br><span class="line">&#125;,<span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<p>缺点：<br>回调地狱，不能捕获错误，不能return</p>
<p>缺乏顺序性，不好调试<br>嵌套函数存在耦合性，如果有改动，会牵动很多东西<br>如果嵌套存在多层会很难维护</p>
<p>优点：<br>解决了同步的问题，能够按照顺序执行，如果有一个任务执行时间过长，后面的任务都会排队等待执行。</p>
<h3 id="二、promise"><a href="#二、promise" class="headerlink" title="二、promise"></a>二、promise</h3><p>Promise是解决callback的问题<br>Promise实现了链式调用，每次 .then 都会返回一个全新的Promise。<br>如果在.then中return，return的结果会被Promise.resolve()包装。</p>
<p>优点：<br>解决了回调地狱的问题</p>
<p>缺点:<br>promise无法被取消，错误需要通过回调函数来捕获</p>
<h3 id="三、generator"><a href="#三、generator" class="headerlink" title="三、generator"></a>三、generator</h3><p>特点：可以控制函数的执行，可以配合co函数使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&#x27;xxx0&#x27;</span>,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&#x27;xxx1&#x27;</span>,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">yield</span> ajax(<span class="string">&#x27;xxx2&#x27;</span>,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch();</span><br><span class="line"><span class="keyword">let</span> result1 = it.next();</span><br><span class="line"><span class="keyword">let</span> result2 = it.next();</span><br><span class="line"><span class="keyword">let</span> result3 = it.next();</span><br></pre></td></tr></table></figure>
<p>generator的.next执行后会返回一个对象。</p>
<h3 id="四、saync-await"><a href="#四、saync-await" class="headerlink" title="四、saync/await"></a>四、saync/await</h3><p>优点：写法简洁，代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题。<br>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。（await不可滥用以免造成阻塞）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>宏任务和微任务</title>
    <url>/2021/09/08/JavaScript-%E5%AE%8F%E4%BB%BB%E5%8A%A1-%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>#macrotask（宏任务） 与 microtask（微任务）<br>macrotask（宏任务）<br>microtask（微任务）<br>两者都是用来表示异步任务的分类</p>
<p>在挂起任务时，JS引擎会将所有任务按照任务类别分类分到这两个任务队列中</p>
<p>首先在  macrotask（宏任务）的队列中（这个队列也被称为task queue） 取出 第一个任务  进行执行，</p>
<p>执行完成后</p>
<p>取出  microtask（微任务）的队列中的所有任务并按照顺序执行</p>
<p>执行完成后<br>(ui试图更新)</p>
<p>再从 macrotask（宏任务）的队列中 取出 一个任务  进行执行，</p>
<p>执行完成后<br>(ui试图更新)</p>
<p>再取出  microtask（微任务）的队列中的所有任务并按照顺序执行</p>
<p>周而复始</p>
<p>………..</p>
<p>直到两个队列中任务都取完执行完成</p>
<p>宏任务包括：<br>script（整体代码）<br>setTimeout<br>setInterval<br>I/O<br>UI交互事件<br>postMessage<br>MessageChannel<br>setImmediate（Node.js）</p>
<p>微任务包括：<br>Promise.then<br>Object.observe<br>MutaionObserve<br>process.nextTick(Node.js)</p>
<pre><code class="javascript">


//主线程直接执行
// console.log(&#39;1&#39;);
//丢到宏事件队列中
setTimeout(function() &#123;
    console.log(&#39;2&#39;);
    process.nextTick(function() &#123;
        console.log(&#39;3&#39;);
    &#125;)
    new Promise(function(resolve) &#123;
        console.log(&#39;4&#39;);
        resolve();
    &#125;).then(function() &#123;
        console.log(&#39;5&#39;)
    &#125;)
&#125;)
//微事件1
process.nextTick(function() &#123;
    // console.log(&#39;6&#39;);
&#125;)
//主线程直接执行
new Promise(function(resolve) &#123;
    // console.log(&#39;7&#39;);
    resolve();
&#125;).then(function() &#123;
    //微事件2
    // console.log(&#39;8&#39;)
&#125;)
//丢到宏事件队列中
setTimeout(function() &#123;
    console.log(&#39;9&#39;);
    process.nextTick(function() &#123;
        console.log(&#39;10&#39;);
    &#125;)
    new Promise(function(resolve) &#123;
        console.log(&#39;11&#39;);
        resolve();
    &#125;).then(function() &#123;
        console.log(&#39;12&#39;)
    &#125;)
&#125;)
//////////////////////
1
7
6
8
2
4
3
5
9
11
10 
12

</code></pre>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/09/08/JavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/25">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/25</a>     （观察者模式，和发布-订阅者 模式）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2021/09/08/JavaScript-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>1、防抖(debounce)：触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p>
<p>举例：就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。</p>
<p>节流(thorttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p>
<p>举例：预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现bug。</p>
<p>2、区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>首屏优化方案</title>
    <url>/2021/09/08/%E4%BC%98%E5%8C%96-%E5%A6%82%E4%BD%95%E5%81%9A%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h5 id="preload与prefetch的区别对比"><a href="#preload与prefetch的区别对比" class="headerlink" title="preload与prefetch的区别对比"></a>preload与prefetch的区别对比</h5><p>两者都是link标签的rel属性<br>除了ref属性<br>还有as（加载文件的属性，浏览器会根据这个确定加载的优先级）、href（加载文件的地址）、onload（加载完成的毁掉函数）、crossrigin（跨域加载的属性）<br>如果加载font文件一定要加上as属性否则会到这二次加载</p>
<p>跨域的文件要加上crossorigin</p>
<p>preload是提前加载<br>一般在加载css的时候会给上这个属性，以免页面在渲染的时候样式没有加载完成导致页面样式错乱</p>
<p>preload有as属性<br>浏览器会通过as属性的值来确定加载的优先级，<br>所以preload既不会影响重要资源的加载，也不会让次要资源影响到自身的加载。</p>
<p>prefetch<br>加载的优先级非常低<br>常用于闲时加载<br>对下个页面做预加载</p>
<p>对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch</p>
<h5 id="async-与-defer的区别对比"><a href="#async-与-defer的区别对比" class="headerlink" title="async 与 defer的区别对比"></a>async 与 defer的区别对比</h5><p>两者都是使script标签异步加载的属性<br>不会因为js的加载导致dom的渲染阻塞</p>
<p>defer虽然是异步加载但是如果多个script标签价了defer在执行js代码的时候还是会按照标签的先后吮吸进行加载。</p>
<p>async不会按照script标签的先后顺序执行，而是谁先加载完成谁先执行。<br>但是如果dom渲染的速度很慢，async的脚本会在页面load完成前就执行了</p>
<h6 id="不加任何属性的script"><a href="#不加任何属性的script" class="headerlink" title="不加任何属性的script"></a>不加任何属性的script</h6><p>文档在解析的过程中，遇到script脚本就会停止解析，去加载script脚本的内容，<br>并且会等到脚本加载完成并执行完成后才会继续加载页面。</p>
<h6 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h6><p>script的加载不会阻塞dom的解析和渲染。<br>当页面解析和渲染完成后等所有脚本加载并按照顺序执行后才会出发DOMContentLoaded。</p>
<blockquote>
<p>依赖dom操作的脚本。</p>
</blockquote>
<h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><p>脚本加载完成后就会去执行。<br>完全和dom的加载渲染异步。<br>脚本的加载不计入DOMContentLoaded的时间统计</p>
<blockquote>
<p>适用于完全不依赖dom的脚本比如埋点统计</p>
</blockquote>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>按需引入<br>分包加载<br>gzip压缩</p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>http2.0<br>预加载<br>cdn分发</p>
<blockquote>
<p>用户距离哪台服务器的距离近就从哪个服务器加载资源</p>
</blockquote>
<p>对网络请求进行合并，将碎片请求进行合并</p>
<h4 id="视觉"><a href="#视觉" class="headerlink" title="视觉"></a>视觉</h4><p>骨架屏<br>loading<br>懒加载 loading=“lazy”<br>路由和组件做动态加载</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>给静态资源增加强缓存</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>做服务端渲染ssr<br>利用好script标签的async和defer这两个属性。功能独立且不要求马上执行的js文件，可以加入async属性。如果是优先级低且没有依赖的js，可以加入defer属性。</p>
]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
  </entry>
  <entry>
    <title>雅虎前端优化的35条规则</title>
    <url>/2021/09/08/%E4%BC%98%E5%8C%96-%E9%9B%85%E8%99%8E%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%9A%8435%E6%9D%A1%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h4 id="1-减少http请求次数"><a href="#1-减少http请求次数" class="headerlink" title="1 减少http请求次数"></a>1 减少http请求次数</h4><p>80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。</p>
<p>合并文件：是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。<br>　　CSS Sprites：是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的background-image和background-position属性来定位要显示的部分。<br>　　图像映射：可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。<br>　　行内图片（Base64编码）：用data: URL模式来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。<br>　　减少页面的HTTP请求数是个起点，这是提升站点首次访问速度的重要指导原则。</p>
<h4 id="2-减少DNS查询次数"><a href="#2-减少DNS查询次数" class="headerlink" title="2 减少DNS查询次数"></a>2 减少DNS查询次数</h4><p>域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入<a href="http://www.yahoo.com的时候,浏览器就会联系dns解析器返回服务器的ip地址.dns是有成本的,它需要20到120毫秒去查找给定主机名的ip地址.在dns查找完成之前,浏览器无法从主机名下载任何东西./">www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。</a><br>　　DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。<br>　　IE默认缓存DNS查找30分钟，写在DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用network.dnsCacheExpiration配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件)<br>　　如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。<br>　　减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。</p>
<h4 id="3-避免重定向"><a href="#3-避免重定向" class="headerlink" title="3 避免重定向"></a>3 避免重定向</h4><p>重定向用301和302状态码，下面是一个有301状态码的HTTP头：<br>HTTP/1.1 301 Moved Permanently<br>      Location: <a href="http://example.com/newuri">http://example.com/newuri</a><br>      Content-Type: text/html<br>　　浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。<br>　　牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。<br>　　有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到<a href="http://astrology.yahoo.com/astrology%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0http://astrology.yahoo.com/astrology/%E7%9A%84301%E5%93%8D%E5%BA%94%EF%BC%88%E6%B3%A8%E6%84%8F%E6%B7%BB%E5%9C%A8%E5%B0%BE%E9%83%A8%E7%9A%84%E6%96%9C%E7%BA%BF%EF%BC%89%E3%80%82%E5%9C%A8Apache%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%94%A8Alias%EF%BC%8Cmod_rewrite%E6%88%96%E8%80%85DirectorySlash%E6%8C%87%E4%BB%A4%E6%9D%A5%E5%8F%96%E6%B6%88%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%82">http://astrology.yahoo.com/astrology会返回一个重定向到http://astrology.yahoo.com/astrology/的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。</a><br>　　重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。</p>
<h4 id="4-让Ajax可缓存"><a href="#4-让Ajax可缓存" class="headerlink" title="4 让Ajax可缓存"></a>4 让Ajax可缓存</h4><p>Ajax可以帮助我们异步的下载网页内容，但是有些网页内容即使是异步的，用户还是在等待它的返回结果，例如ajax的返回是用户联系人的下拉列表。所以我们还是要注意尽量应用以下规则提高ajax的响应速度。<br>  ● Gzip组件   (压缩回复内容)<br>  ● 添加Expires或Cache-Control报文头使回复可以被客户端缓存<br>  ● 减少DNS查找<br>  ● 压缩JavaScript<br>  ● 避免重定向<br>  ● 配置ETags</p>
<h4 id="5-延迟加载"><a href="#5-延迟加载" class="headerlink" title="5 延迟加载"></a>5 延迟加载</h4><p>这里讨论延迟加载需要我们知道我们的网页最初加载需要的最小内容集是什么。剩下的内容就可以推到延迟加载的集合中。<br>Javascript是典型的可以延迟加载内容。一个比较激进的做法是开发网页时先确保网页在没有Javascript的时候也可以基本工作，然后通过延迟加载脚本来完成一些高级的功能。<br>YUI Get utility<br>YUI Image Loader</p>
<h4 id="6-预加载"><a href="#6-预加载" class="headerlink" title="6 预加载"></a>6 预加载</h4><p>预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。<br>实际应用中有以下几种预加载的类型：<br>  ● 无条件预加载——尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。<br>  ● 条件性预加载——根据用户操作猜测用户将要跳转到哪里并据此预加载。在search.yahoo.com的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。<br>  ● 提前预加载——在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。</p>
<h4 id="7-减少DOM元素的数量"><a href="#7-减少DOM元素的数量" class="headerlink" title="7 减少DOM元素的数量"></a>7 减少DOM元素的数量</h4><p>一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。<br>　　大量的DOM元素是一种征兆——页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添了一堆的<div>s？或许应该用更好的语义化标记。<br>YUI CSS utilities对布局有很大帮助：grids.css针对整体布局，fonts.css和reset.css可以用来去除浏览器的默认格式。这是个开始清理和思考标记的好机会，例如只在语义上有意义的时候使用<div>，而不是因为它能够渲染一个新行。<br>　　DOM元素的数量很容易测试，只需要在Firebug的控制台里输入：<br>document.getElementsByTagName(‘*’).length</p>
<p>YUI CSS utilities     <a href="https://yuilibrary.com/">https://yuilibrary.com/</a></p>
<h4 id="8-跨域分离组件"><a href="#8-跨域分离组件" class="headerlink" title="8 跨域分离组件"></a>8 跨域分离组件</h4><p>分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在<a href="http://www.example.org,而把静态组件分离到static1.example.org和static2.example.org./">www.example.org，而把静态组件分离到static1.example.org和static2.example.org。</a></p>
<h4 id="9-尽量少用iframe"><a href="#9-尽量少用iframe" class="headerlink" title="9 尽量少用iframe"></a>9 尽量少用iframe</h4><p>用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。<br>iframe的优点：<br>  ● 引入缓慢的第三方内容，比如标志和广告<br>  ● 安全沙箱<br>  ● 并行下载脚本<br>iframe的缺点：<br>  ● 代价高昂，即使是空白的iframe<br>  ● 阻塞页面加载<br>  ● 非语义</p>
<h4 id="10-杜绝404"><a href="#10-杜绝404" class="headerlink" title="10  杜绝404"></a>10  杜绝404</h4><p>HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。<br>　　有些站点用的是有帮助的404——“你的意思是xxx？”，这样做有利于用户体验，，但也浪费了服务器资源（比如数据库等等）。最糟糕的是链接到的外部JavaScript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是JavaScript代码，需要找出其中可用的部分。</p>
<p>CSS部分</p>
<h4 id="11-避免使用css表达式"><a href="#11-避免使用css表达式" class="headerlink" title="11 避免使用css表达式"></a>11 避免使用css表达式</h4><p>用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。CSS表达式的问题在于它被重新计算的次数远比我们想象的要多，不仅在网页绘制或大小改变时计算，即使我们滚动屏幕或者移动鼠标的时候也在计算，因此我们还是尽量避免使用它来防止使用不当而造成的性能损耗。</p>
<h4 id="12-选择舍弃-import"><a href="#12-选择舍弃-import" class="headerlink" title="12 选择舍弃@import"></a>12 选择<link>舍弃@import</h4><p>前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。<br>  在IE中用@import与在底部用<link>效果一样，所以最好不要用它。</p>
<h4 id="13-避免使用滤镜"><a href="#13-避免使用滤镜" class="headerlink" title="13  避免使用滤镜"></a>13  避免使用滤镜</h4><p>IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。<br>最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。</p>
<h4 id="14-把样式表放在顶部"><a href="#14-把样式表放在顶部" class="headerlink" title="14 把样式表放在顶部"></a>14 把样式表放在顶部</h4><p>在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。</p>
<h3 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h3><h4 id="15-去除重复脚本"><a href="#15-去除重复脚本" class="headerlink" title="15 去除重复脚本"></a>15 去除重复脚本</h4><p>重复的脚本不仅浪费浏览器的下载时间，而且浪费解析和执行时间。一般用来避免引入重复脚本的做法是使用统一的脚本管理模块，这样不仅可以避免重复脚本引入，还可以兼顾脚本依赖管理和版本管理。</p>
<h4 id="16-尽量减少DOM访问"><a href="#16-尽量减少DOM访问" class="headerlink" title="16  尽量减少DOM访问"></a>16  尽量减少DOM访问</h4><p>用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：<br>  ● 缓存已访问过的元素的索引<br>  ● 先“离线”更新节点，再把它们添到DOM树上<br>  ● 避免用JavaScript修复布局问题</p>
<h4 id="17-用智能的事件处理器"><a href="#17-用智能的事件处理器" class="headerlink" title="17 用智能的事件处理器"></a>17 用智能的事件处理器</h4><p>有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。</p>
<h4 id="18-把脚本放在底部"><a href="#18-把脚本放在底部" class="headerlink" title="18 把脚本放在底部"></a>18 把脚本放在底部</h4><p>HTTP/1.1 specification建议浏览器对同一个hostname不要超过两个并行下载连接， 所以当你从多个domain下载图片的时候可以提高并行下载连接数量。但是当脚本在下载的时候，即使是来自不同的hostname浏览器也不会下载其他资源，因为浏览器要在脚本下载之后依次解析和执行。<br>因此对于脚本提速，我们可以考虑以下方式，<br>  ● 把脚本置底，这样可以让网页渲染所需要的内容尽快加载显示给用户。<br>  ● 现在主流浏览器都支持defer关键字，可以指定脚本在文档加载后执行。<br>  ● HTML5中新加了async关键字，可以让脚本异步执行。</p>
<h3 id="javascript-css"><a href="#javascript-css" class="headerlink" title="javascript,css"></a>javascript,css</h3><h4 id="19-引用外部javascript和css"><a href="#19-引用外部javascript和css" class="headerlink" title="19 引用外部javascript和css"></a>19 引用外部javascript和css</h4><p>使用外部Javascript和CSS文件可以使这些文件被浏览器缓存，从而在不同的请求内容之间重用。<br>同时将Javascript和CSS从inline变为external也减小了网页内容的大小。<br>使用外部Javascript和CSS文件的决定因素在于这些外部文件的重用率，如果用户在浏览我们的页面时会访问多次相同页面或者可以重用脚本的不同页面，那么外部文件形式可以为你带来很大的好处。但对于用户通常只会访问一次的页面，例如microsoft.com首页，那inline的javascript和css相对来说可以提供更高的效率。</p>
<h4 id="20-压缩javascript和css"><a href="#20-压缩javascript和css" class="headerlink" title="20 压缩javascript和css"></a>20 压缩javascript和css</h4><p>压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是JSMin和YUI Compressor，YUI compressor还可以压缩CSS。<br>　　混淆是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生bug。在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。<br>　　除了压缩外部脚本和样式，行内的script和style块也可以压缩。即使启用了gzip模块，先进行压缩也能够缩小5%或者更多的大小。JavaScript和CSS的用处越来越多，所以压缩代码会有不错的效果。</p>
<p>用来帮助我们做精简的工具很多，主要可以参考如下，<br>JS compressors:<br>  ● Packer<br>  ● JSMin<br>  ● Closure compiler<br>  ● YUICompressor (also does CSS)<br>  ● AjaxMin (also does CSS)<br>CSS compressors:<br>  ● CSSTidy<br>  ● Minify<br>  ● YUICompressor (also does JS)<br>  ● AjaxMin (also does JS)<br>  ● CSSCompressor</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><h4 id="21-优化图片"><a href="#21-优化图片" class="headerlink" title="21 优化图片"></a>21 优化图片</h4><p>  ● 尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）</p>
<h4 id="22-优化CSS-Sprite"><a href="#22-优化CSS-Sprite" class="headerlink" title="22 优化CSS Sprite"></a>22 优化CSS Sprite</h4><p>  ● 在Sprite图片中横向排列一般都比纵向排列的最终文件小<br>  ● 组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式<br>  ● “对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。</p>
<h4 id="23-不要用HTML缩放图片"><a href="#23-不要用HTML缩放图片" class="headerlink" title="23 不要用HTML缩放图片"></a>23 不要用HTML缩放图片</h4><p>不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要<br>1 <img width="100" height="100" src="mycat.jpg" alt="My Cat" /><br>　　那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。</p>
<h4 id="24-用小的可缓存的favicon-ico-收藏夹图标"><a href="#24-用小的可缓存的favicon-ico-收藏夹图标" class="headerlink" title="24  用小的可缓存的favicon.ico(收藏夹图标)"></a>24  用小的可缓存的favicon.ico(收藏夹图标)</h4><p>favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。<br>所以为了缓解favicon.ico的缺点，应该确保：<br>  ● 足够小，最好在1K以下<br>  ● 设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><h4 id="25-给cookie减肥"><a href="#25-给cookie减肥" class="headerlink" title="25 给cookie减肥"></a>25 给cookie减肥</h4><p>使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。<br>  ● 清除不必要的cookie<br>  ● 保证cookie尽可能小，以最小化对用户响应时间的影响<br>  ● 注意给cookie设置合适的域级别，以免影响其它子域<br>  ● 设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间</p>
<h4 id="26-把组件放在不含cookie的域下"><a href="#26-把组件放在不含cookie的域下" class="headerlink" title="26 把组件放在不含cookie的域下"></a>26 把组件放在不含cookie的域下</h4><p>当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。<br>　　如果域名是<a href="http://www.example.org,可以把静态组件部署到static.example.org.然而,如果已经在顶级域example.org或者www.example.org设置了cookie,那么所有对static.example.org的请求都会含有这些cookie.这时候可以再买一个新域名,把所有的静态组件部署上去,并保持这个新域名不含cookie.yahoo!用的是yimg.com,youtube是ytimg.com,amazon是images-amazon.com等等./">www.example.org，可以把静态组件部署到static.example.org。然而，如果已经在顶级域example.org或者www.example.org设置了cookie，那么所有对static.example.org的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是yimg.com，YouTube是ytimg.com，Amazon是images-amazon.com等等。</a><br>　　把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是<a href="http://www.example.org作为主页,可以考虑一下cookie的影响.省略www的话,就只能把cookie写到*.example.org,所以因为性能原因最好用www子域,并且把cookie写到这个子域下./">www.example.org作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。</a></p>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><h4 id="27-保证所有组件都小于25k"><a href="#27-保证所有组件都小于25k" class="headerlink" title="27 保证所有组件都小于25k"></a>27 保证所有组件都小于25k</h4><p>这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。</p>
<h4 id="28-把组件打包到一个复合文档里"><a href="#28-把组件打包到一个复合文档里" class="headerlink" title="28 把组件打包到一个复合文档里"></a>28 把组件打包到一个复合文档里</h4><p>把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组建。当你使用这条规则时，首先要确定用户代理是否支持（iPhone不支持）。</p>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><h4 id="29-Gzip压缩传输文件"><a href="#29-Gzip压缩传输文件" class="headerlink" title="29 Gzip压缩传输文件"></a>29 Gzip压缩传输文件</h4><p>Gzip通常可以减少70%网页内容的大小，包括脚本、样式表、图片等文件。Gzip比deflate更高效，主流服务器都有相应的压缩支持模块。<br>IIS中内建了静态压缩和动态压缩模块，如何配制可以参考Enable HTTP Compression of Static Content (IIS 7)和Enable HTTP Compression of Dynamic Content (IIS 7)。<br>值得注意的是pdf文件可以从需要被压缩的类型中剔除，因为pdf文件本身已经压缩，gzip对其效果不大，而且会浪费CPU。</p>
<h4 id="30-避免图片src属性为空"><a href="#30-避免图片src属性为空" class="headerlink" title="30 避免图片src属性为空"></a>30 避免图片src属性为空</h4><p>空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。尤其是你的网站每天被很多人访问的时候，这种空请求造成的伤害不容忽略。<br>浏览器如此实现也是根据RFC 3986 - Uniform Resource Identifiers标准，空的src被定义为当前页面。<br>所以注意我们的网页中是否存在这样的代码<br>straight HTML<br><img src=""><br>JavaScript<br>var img = new Image();<br>img.src = “”;</p>
<h4 id="31-配置ETags"><a href="#31-配置ETags" class="headerlink" title="31 配置ETags"></a>31 配置ETags</h4><p>虽然标题叫配制ETags，但是这里你要根据具体情况进行一些判断。首先Etag简单来说是通过一个文件版本标识使得服务器可以轻松判断该请求的内容是否有所更新，如果没有就回复304 (not modified)，从而避免下载整个文件。<br>但是Etags的版本信息即使主流服务器未能很好地支持跨服务器的判断，比如你从一个服务器集群中一台得到Etags，然后发送到了另一台那么校验很有可能会失败。</p>
<h4 id="32-对Ajax用GET请求"><a href="#32-对Ajax用GET请求" class="headerlink" title="32 对Ajax用GET请求"></a>32 对Ajax用GET请求</h4><p>get 用来检索信息，所以他的语义只是用get请求来请求数据<br>post 用来发送需要存储到服务器的数据</p>
<h4 id="33-尽早清空缓冲区"><a href="#33-尽早清空缓冲区" class="headerlink" title="33 尽早清空缓冲区"></a>33 尽早清空缓冲区</h4><p>网页后台程序中我们知道有个方法叫Response.Flush()，一般我们调用它都是在程序末尾，但注意这个方法可以被调用多次。目的是可以将现有的缓存中的回复内容先发给客户端，让客户端“有活干”。<br>那在什么时候调用这个方法比较好呢？一般情况下我们可以在对于需要加载比较多外部脚本或者样式表时可以提前调用一次，客户端收到了关于脚本或其他外部资源的链接可以并行的先发请求去下载，服务器接下来把后续的处理结果发给客户端。<br>当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。<br>　　较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。<br>例如：</p>
<pre><code>&lt;/head&gt;
&lt;?php flush(); ?&gt;
&lt;body&gt;
</code></pre>
<h4 id="34-使用CDN（内容分发网络）"><a href="#34-使用CDN（内容分发网络）" class="headerlink" title="34 使用CDN（内容分发网络）"></a>34 使用CDN（内容分发网络）</h4><p>　记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。</p>
<h4 id="35-添上Expires或者Cache-Control-HTTP头"><a href="#35-添上Expires或者Cache-Control-HTTP头" class="headerlink" title="35 添上Expires或者Cache-Control HTTP头"></a>35 添上Expires或者Cache-Control HTTP头</h4><p>这条规则有两个方面：<br>  ● 对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效<br>  ● 多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求<br>　　网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在所有组件上，包括脚本、样式和Flash组件。<br>　　浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。</p>
]]></content>
      <categories>
        <category>前端优化</category>
      </categories>
  </entry>
  <entry>
    <title>浅析vue-loader</title>
    <url>/2021/09/08/%E6%A8%A1%E5%9D%97%E5%8C%96-vue-loadre/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>模块化</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器的线程</title>
    <url>/2021/09/08/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="浏览器是多线程的"><a href="#浏览器是多线程的" class="headerlink" title="浏览器是多线程的"></a>浏览器是多线程的</h3><p>1.GUI渲染线程<br>2.javaScript引擎线程<br>3.定时器线程<br>4.事件线程<br>5.异步请求线程</p>
<p>为了防止渲染出现不可预期的结果（js修改css或者dom）,GUI渲染线程和javaScript引擎线程是互斥的。<br><img src="./../assets/images/thread.jpg" alt="thread.png" title="thread"></p>
<h3 id="渲染线程"><a href="#渲染线程" class="headerlink" title="渲染线程"></a>渲染线程</h3><p>1.解析Dom 构建为Dom tree<br>2.解析Css 构建为Css rule tree<br>3.将Css的规则树和Dom树进行合并生成render tree<br>4.回流（reflow或者layout）：计算每个盒子的位置和大小<br>5.重绘（repaint）：根据位置和大小，计算元素的绝对像素<br>6.渲染（Display）：将绝对位置给到GPU，将多个层进行合并，形成一个层，渲染到浏览器上。<br><img src="./../assets/images/render.png" alt="render.png" title="render"></p>
<blockquote>
<p>元素进行新增或者删除，或者改变大小或者位置，都会触发节点的回流（重排 reflow）。浏览器是流式布局的。</p>
</blockquote>
<blockquote>
<p>由于浏览器是使用流式布局的 ，对render Tree的计算通常只用遍历一次就可以完成了，但table以及内部元素除外，他们可能需要计算多次，通常是花三倍同等元素的时间，这也是避免使用table布局的原因之一。</p>
</blockquote>
<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>由于节点的几何属性或者样式发生了改变但是不影响布局的，称为重绘，例如 outline, visibility, color、background-color等，<br>重绘的代价是高昂的，因为浏览器必须要验证dom树上的其他节点的可见，</p>
<h4 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h4><p>是布局或者几何结构发生了改变，重排是影响浏览器性能的重要因素。<br>因为它涉及到浏览器局部或者整个页面的刷新。<br>一个元素的回流可能会影响到整个dom的子元素，或者父元素，甚至祖先元素跟着重排。</p>
<blockquote>
<p>重排必定重绘，重绘不一定重排。</p>
</blockquote>
<h3 id="优化的方式"><a href="#优化的方式" class="headerlink" title="优化的方式"></a>优化的方式</h3><p>1.避免使用js操作dom<br>2.style样式改变通过class而不是手动修改<br>3.开启GPU加速渲染will-change和translateZ<br>4.documentFragment离线操作dom<br>5.比较耗时的操作放到webworker中完成</p>
<h3 id="script-defer和async"><a href="#script-defer和async" class="headerlink" title="script defer和async"></a>script defer和async</h3><p>1.async属性会异步下载script，下载后立即执行，下载完成前不会影响html解析。<br>2.defer属性会异步下载script，下载后延迟执行，等到html解析完成后，执行完成后出发DOMcontentLoaded事件。<br>3.async是无序的  defer是有序的</p>
<h3 id="减少重绘与回流"><a href="#减少重绘与回流" class="headerlink" title="减少重绘与回流"></a>减少重绘与回流</h3><h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><p>1.使用 transform 替代 top</p>
<p>2.使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局</p>
<p>3.避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。</p>
<p>4.尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。</p>
<p>5.避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。</p>
<p>6.将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。</p>
<p>7.避免使用CSS表达式，可能会引发回流。</p>
<p>8.将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。</p>
<p>9.CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p>
<h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><p>1.避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。<br>2.避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。<br>3.避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。<br>4.对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器的缓存</title>
    <url>/2021/09/08/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p><img src="./../assets/images/cach.webp" alt="cach.webp" title="cach"></p>
<h4 id="缓存的几个位置"><a href="#缓存的几个位置" class="headerlink" title="缓存的几个位置"></a>缓存的几个位置</h4><ol>
<li>service worker</li>
<li>Memory Cach</li>
<li>Disk Cach</li>
<li>push Cach</li>
</ol>
<h4 id="service-worker"><a href="#service-worker" class="headerlink" title="service worker"></a>service worker</h4><p>基于浏览器和服务器中间的角色，注册过service work后就可以拦截到当前网站的所有请求。<br>拦截到请求后如果需要发起请求就把请求发给服务器，如果使用缓存就返回缓存数据。</p>
<blockquote>
<p>注意点<br>使用 service worker 必须要使用https<br>运行在work的上下文中，不能访问DIOM<br>设计为异步的同步API无法在service中使用（XHR或者localStorage）<br>生命周期和页面无关</p>
</blockquote>
<p>在浏览器兼容</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title>前端安全防护</title>
    <url>/2021/09/08/%E5%AE%89%E5%85%A8-%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack是什么</title>
    <url>/2021/09/08/%E6%A8%A1%E5%9D%97%E5%8C%96-webpack/</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/6844904079219490830">带你深度解锁Webpack系列(基础篇)</a><br><a href="https://juejin.cn/post/6844904084927938567">带你深度解锁Webpack系列(进阶篇)</a><br><a href="https://juejin.cn/post/6844904093463347208">带你深度解锁Webpack系列(优化篇)</a></p>
<p><a href="https://aotu.io/notes/Referer2020/07/17/webpack-analize/index.html">Webpack原理浅析 | Aotu.io「凹凸实验室」</a><br><a href="https://juejin.cn/post/6924258563862822919">Webpack5 新特性业务落地实战</a></p>
<p>[[使用webpack4提升180%编译速度]]<br><a href="https://juejin.cn/post/6844903652956569608">手摸手，带你用合理的姿势使用webpack4（上）</a></p>
<p><a href="https://juejin.cn/post/6924180659829211143">从零使用 Webpack5 搭建一个完整的 Vue3 的开发环境</a></p>
<p><a href="https://imweb.io/topic/5da1397aaf03a41f046a8df1">webpack源码阅读之Compiler - 腾讯Web前端 IMWeb 团队社区 | blog | 团队博客</a></p>
<p><a href="https://www.alienzhou.com/2020/03/28/improvement-in-webpack/">聊一聊 webpack 的打包优化实践 - AlienZHOU 的个人站点</a></p>
<p><a href="https://xie.infoq.cn/article/c48403d68f6b75356c02edb69">webpack | 谈谈webpack的本质</a></p>
<p>热替换</p>
<p>分包策略</p>
<p><a href="https://survivejs.com/webpack/foreword/">Foreword</a></p>
]]></content>
      <categories>
        <category>模块化</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器页面渲染机制</title>
    <url>/2021/09/08/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24</a></p>
<p><a href="https://github.com/shuch/blog/issues/17">https://github.com/shuch/blog/issues/17</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title>跨域CORS</title>
    <url>/2021/09/08/%E7%BD%91%E7%BB%9C-CORS%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h4 id="跨域CORS"><a href="#跨域CORS" class="headerlink" title="跨域CORS"></a>跨域CORS</h4><p>Cross-origin resource sharing<br>跨域资源共享<br>允许浏览器向跨源服务器发出 XMLHttpRequest请求   克服ajax只能同源请求的限制</p>
<p>跨域请求需要浏览器和服务器同时支持  目前浏览器都支持该功能，IE必须10以上</p>
<p>跨域请求被分为两种  简单请求和非简单请求<br>满足一下俩点的为简单请求<br>1.请求方法是HEAD GET POST请求三者<br>2.http的请求头信息不得超出以下字段<br>  (1)Accept<br>  (2)Accept-Language<br>  (3)content-Language<br>  (4)Last-Event-ID<br>  (5)Content-Type: 只能是application/x-www-urlencoded、multipart/form-data、text/plain</p>
<p>只要满足上述的条件就是简单请求，   浏览器对简单请求和非简单清楚的处理方式是不同的</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>简单请求浏览器会直接发出请求，在请求头信息中会增加Origin字段<br>Origin字段的作用是来说明  这次请求是来自哪个源（协议 + 域名 + 端口）即同源策略的三个内容。    服务器会根据请求的源信息来判断是否同意该请求</p>
<p>如果Origin制定的源不在服务器的允许的范围内 服务器会返回正常的http回应，但是浏览器看到请求回应的头信息中没有包涵Access-Control-Allow-Origin字段<br>就知道出错了，会抛出跨域请求失败的错误   会被XMLHttprequest 的 onerror 函数捕捉。<br>这种错误无法通过状态码识别，因为除了 403 还有可能会返回 200 </p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应头中会有以下的信息<br>Access-Control-Allow-Origin: <a href="http://www.baidu.com/">http://www.baidu.com</a><br>Access-Control-Allow-Credentials: true<br>Access-Control-Expose-Headers: FooBar<br>Content-Type: text/html; charset=utf-8</p>
<p>三个字段都以Access-Control-开头</p>
<p>Access-Control-Allow-Origin<br>该字段的值要么是Origin制定的域名  要么是*</p>
<p>Access-Control-Allow-Credentials<br>该字段的值是一个布尔值，表示是否允许发送Cookie。默认情况下跨域请求是不携带cookie的 即默认值为false<br>如果值设置为true   Cookie就可以包含在请求中，一起发给服务器。这个值只能设置为true，如果服务器不要浏览器发送cookie删除该字段即可</p>
<p>Access-Control-Expose-Headers<br>CORS请求时，getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。<br>如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</p>
<p>如果跨域请求需要发送cookie 除了设置Access-Control-Allow-Origin的值为true，<br>还需要设置 withCredentials 的值为true。</p>
<p>var xhr = new XMLHttpRequest();<br>xhr.withCredentials = true;</p>
<p>有些浏览器会默认将withCredentials值设置为true，如果不想上传cookie那就将withCredentials设置为false就可以了。</p>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>非简单请求是有特殊要求的跨域请求，比如请求方式是put或者delete，或者Content-Type字段的值为 application/json 。<br>非简单的跨域请求在正式通信前会增加一次http查询请求，称为预检请求（preflight）。<br>浏览器会先询问服务器，当前网页所在的域名是否在服务器的许可名单中，以及可以使用那些HTTP动词和头信息。只有的到正确的答复，浏览器才会发出正式的XMLHttpRequest请求，否则就会报错。</p>
<p>预检请求的请求方式是OPTIONS，表示这个请求是用来询问的。</p>
<h6 id="请求头里的关键字段"><a href="#请求头里的关键字段" class="headerlink" title="请求头里的关键字段"></a>请求头里的关键字段</h6><p>Origin：表示是来自哪里的请求<br>Access-Control-Request-Method: 必要字段，用来列出浏览器的跨域请求会用到那些HTTP方法。<br>Access-Control-Request-Headers: 该字段是一个逗号分隔的字符串，指定浏览器跨域请求会额外发送的字段信息。</p>
<h6 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h6><p>Access-Control-Allow-Origin: 表示请求的来源<br>Access-Control-Allow-Methods: 表示服务器支持的所有跨域请求方法<br>Access-Control-Allow-Credentials: 该字段的值是一个布尔值，表示是否允许发送Cookie。默认情况下跨域请求是不携带cookie的 即默认值为false,如果值设置为true,Cookie就可以包含在请求中，一起发给服务器。这个值只能设置为true，如果服务器不要浏览器发送cookie删除该字段即可.<br>Access-Control-Max-Age: 选填字段，用来指定本次预检请求的有效期，单位为秒。设置后在这个时间范围内不用再发出另外一条预检请求。</p>
<p>一旦服务器通过了预检请求，往后的每次跨域请求就会和简单请求一样。</p>
<h4 id="与JSONP的比较"><a href="#与JSONP的比较" class="headerlink" title="与JSONP的比较"></a>与JSONP的比较</h4><p>CORS与JSONP的使用目的相同，都为解决跨域问题，但是比JSONP更强大。<br>JSONP只能支持get请求，CORS支持所有的Http请求。JSONP则具有更强的兼容性，以及可以向不支持CORS的网站请求数据</p>
<p>JSONP优缺点<br>1.它只支持GET请求而不支持POST等其它类型的HTTP请求<br>2.它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。<br>3.jsonp在调用失败的时候不会返回各种HTTP状态码。</p>
<p>4.缺点是安全性。万一假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。那么结果是什么？所有调用这个 jsonp的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用jsonp的时候必须要保证使用的jsonp服务必须是安全可信的。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP、HTTPS</title>
    <url>/2021/09/08/%E7%BD%91%E7%BB%9C-http/</url>
    <content><![CDATA[<h3 id="http协议概述"><a href="#http协议概述" class="headerlink" title="http协议概述"></a>http协议概述</h3><p>http是一个客户端和服务端请求应答的标准<br>通过网络请求或者网络爬虫或其他工具，客户端发起一个http请求到服务端的制定端口（80）<br>应答的服务器上存放着资源，html文件，图片，等等<br>应答服务器称之为源服务器<br>在用户和源服务中间可能有多个中间层，比如代理服务器，网关，隧道 等</p>
<p>尽管TCP/IP协议是最流行的传输协议<br>但是http协议并没有规定必须使用TCP/IP<br>http可以在任何互联网协议上，或其他网络上实现<br>http协议会假定下层的协议是安全可靠的，因此能够提供这种保障的都可以被其使用，<br>TCP是传输层协议，http是应用层协议</p>
<p>客户端连接到服务端 与服务端建立TCP套接字连接<br>发送http请求<br>客户端发送一个文本的请求报文<br>由请求行，请求头，空行、请求数据四部分组成<br>服务端收到请求后解析请求，定位请求资源 将资源复写到TCP套接字，由客户端进行读取，由状态行，响应头、空行、返回数据四部分组成<br>如果connection模式是false则服务器主动关闭连接，如果值为keppAlive则连接会保持一段时间，在这段时间是可以继续进行数据传输的<br>客户端收到相应数据后<br>会先解析状态行，查看请求是否成功，<br>然后读取响应头，<br>然后读取响应数据，将响应的数据在页面中进行展示</p>
<h3 id="在浏览器地址栏输入URL，按下回车之后会经历以下流程："><a href="#在浏览器地址栏输入URL，按下回车之后会经历以下流程：" class="headerlink" title="在浏览器地址栏输入URL，按下回车之后会经历以下流程："></a>在浏览器地址栏输入URL，按下回车之后会经历以下流程：</h3><p>1.浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2.解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5.释放 TCP连接;<br>6.浏览器将该 html 文本并显示内容; 　</p>
<h3 id="http的特点"><a href="#http的特点" class="headerlink" title="http的特点"></a>http的特点</h3><p>http协议规定，在发起http请求的时候，一定是从客户端开始发起链接请求，服务端在没有接收到请求的时候是不会向服务端发送响应。<br>http是无状态的  是不对响应和请求之间的状态做保存的，协议对发送过的请求和响应是不做持久化处理的。<br>http是无连接的，也就是说每次连接只处理一个请求，服务器处理完客户端的请求，并收到客户端的应答后，就会断掉链接，采用这种方式，可以节省传输时间，和提高并发性能</p>
<h3 id="无连接的两种方式："><a href="#无连接的两种方式：" class="headerlink" title="无连接的两种方式："></a>无连接的两种方式：</h3><p>一个请求一个响应之后就直接断开了。  </p>
<p>但是在http1.1中不是这样的而是会等待几秒钟，这几秒钟就是在等待客户端的操作，如果这个时候用户还有新的请求，就不用再重新发起连接<br>还是通过直接的连接进行收发消息，因为没次建立连接的三次握手也是耗时的。</p>
<p>不支持该请求方式时状态码为405<br>错误的请求方式时状态码为501</p>
<h5 id="为什么http建立连接需要三次握手，不是两次或四次"><a href="#为什么http建立连接需要三次握手，不是两次或四次" class="headerlink" title="为什么http建立连接需要三次握手，不是两次或四次?"></a>为什么http建立连接需要三次握手，不是两次或四次?</h5><p>答：三次是最少的安全次数，两次不安全，四次浪费资源；</p>
<h4 id="SPDY协议"><a href="#SPDY协议" class="headerlink" title="SPDY协议"></a>SPDY协议</h4><p>http2是基于spdy协议<br>spdy协议是基于TCP的应用层协议<br>目标 是优化http的性能<br>通过压缩、多路复用、优先级等技术缩短页面的加载时间和提高安全<br>SPDY的核心思想是减少TCP的连接数量<br>SPDY协议不是替代http协议而是增强HTTP协议</p>
<h4 id="http1的缺点"><a href="#http1的缺点" class="headerlink" title="http1的缺点"></a>http1的缺点</h4><p>1.http1 一次只允许一个TCP的链接请求，1.1的处理并发的方式也比较局限性，客户端发起多次请求的时候也会导致队列头的阻塞。<br>2.单向请求，只能由客户端发起请求<br>3.请求头和响应头的信息冗杂<br>4.数据未压缩，导致数据传输量过大</p>
<h4 id="http2的优化点"><a href="#http2的优化点" class="headerlink" title="http2的优化点"></a>http2的优化点</h4><h5 id="1-二进制分帧"><a href="#1-二进制分帧" class="headerlink" title="1.二进制分帧"></a>1.二进制分帧</h5><p>http1的数据传输方式是通过文本的形式进行传输，在二中则使用可以将传输信息分为更小的帧的形式进行传输，<br>原来的请求头封装到headers帧<br>原来的request body 封装到Data帧</p>
<h5 id="2-首部压缩"><a href="#2-首部压缩" class="headerlink" title="2.首部压缩"></a>2.首部压缩</h5><p>http1是不支持首部压缩的<br>SPDY使用DEFLATE算法和http2使用HPACK算法对头部进行压缩</p>
<p>http1中使用文本的形式进行头信息的传输，如果携带了cookie则每次都要进行传输<br>http2中通过算法对头部进行了压缩，并且在客户端和服务端同时维护两张索引表，其中记录出现过的header<br>在后面的传输中就可以通过键名进行传递，两端收到数据后就可以通过键名找到对应的值</p>
<h5 id="3-多路复用"><a href="#3-多路复用" class="headerlink" title="3.多路复用"></a>3.多路复用</h5><p>1.同一域名下，只需要建立一个连接。 =&gt; 减少握手等待时间，以及多个 tcp 竞争带宽。<br>2.单个连接可以承受任意数量的双向数据流。 =&gt; 并行多个请求响应。<br>3.数据流以消息的形式发送，消息由一个或多个帧组成；帧可以乱序发送，根据帧头部的流标识重新组装。 =&gt; 可以设置一个 31 bit 的优先级，有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。<br>建立一次链接（三次握手只进行一次）<br>然后将消息分解为独立的帧，<br>可无序的进行信息传递<br>在另一端根据帧头部的流标识将传递的信息进行重新组装<br>可避免http的队头阻塞。</p>
<h5 id="4-请求优先级"><a href="#4-请求优先级" class="headerlink" title="4.请求优先级"></a>4.请求优先级</h5><p>当请求的信息被分为多个帧之后，可以通过优化传输顺序来起到优化性能的作用</p>
<h5 id="5-服务器推送"><a href="#5-服务器推送" class="headerlink" title="5.服务器推送"></a>5.服务器推送</h5><p>服务器可以在接受到一个请求后对客户端发起多个响应<br>服务器向客户端推送资源无需客户端进行确认<br>比如服务端收到你首页的请求时可以同时响应多个资源，服务端知道这些资源都是客户端所需要的，这样就加快了页面的渲染速度<br>推送的确定是必须遵守同源策略，服务器不能随便将三方资源推送给客户端，而且必须是两端都确认过才行。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>客户端发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，服务器由SYN=1知道客户端要求建立联机（客户端：我要连接你）</p>
<p>服务器收到请求后要确认联机信息，向A发送ack number=(客户端的seq+1),syn=1,ack=1,随机产生seq=7654321的包（服务器：好的，你来连吧）</p>
<p>客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number=(服务器的seq+1),ack=1，服务器收到后确认seq值与ack=1则连接建立成功。（客户端：好的，我来了）</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>Client向Server发送FIN包，表示Client主动要关闭连接，然后进入FIN_WAIT_1状态，等待Server返回ACK包。此后Client不能再向Server发送数据，但能读取数据。</p>
<p>Server收到FIN包后向Client发送ACK包，然后进入CLOSE_WAIT状态，此后Server不能再读取数据，但可以继续向Client发送数据。</p>
<p>Client收到Server返回的ACK包后进入FIN_WAIT_2状态，等待Server发送FIN包。</p>
<p>Server完成数据的发送后，将FIN包发送给Client，然后进入LAST_ACK状态，等待Client返回ACK包，此后Server既不能读取数据，也不能发送数据。</p>
<p>Client收到FIN包后向Server发送ACK包，然后进入TIME_WAIT状态，接着等待足够长的时间（2MSL）以确保Server接收到ACK包，最后回到CLOSED状态，释放网络资源。</p>
<p>Server收到Client返回的ACK包后便回到CLOSED状态，释放网络资源。</p>
<h5 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h5><p>TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：</p>
<p>客户端：我要关闭输入通道了。（通知）<br>服务端：好的，我检查下有咩有还要传输的数据。（收到通知，并进行确认）</p>
<p>服务端：我检查好了可以关闭了  我关闭输入通道了。（确认完毕后，向客户端发起通知）<br>客户端：好的你关闭吧，我也把这个通道关闭。（最后回复）</p>
<h3 id="http的发展历程"><a href="#http的发展历程" class="headerlink" title="http的发展历程"></a>http的发展历程</h3><p>版本         产生时间                   内容                                                发展现状<br>HTTP/0.9    1991年                   不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求                   没有作为正式的标准<br>HTTP/1.0    1996年                   传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令               正式作为标准<br>HTTP/1.1    1997年                   持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码                      2015年前使用最广泛<br>HTTP/2      2015年                   多路复用、服务器推送、头信息压缩、二进制协议等                                 逐渐覆盖市场</p>
<h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>1.客户端对服务端发起请求（携带浏览器支持的加密算法和哈希算法。）<br>2.服务端返回证书给客户端</p>
<p>3.客户端端拿到证书在客户端校验证书的合法性（不合法提示警告）（使用证书的公钥解密得到证书内容，然后校验证书）<br>4.客户端生成随机密钥x（随机数生成）<br>5.客户端再用证书的公钥加密密钥x<br>6.客户端把加密后的密钥x给到服务端</p>
<p>7.服务端收到后用私钥解密加密后的密钥x<br>8.服务端端用密钥x对网页内容进行加密（对称加密算法）<br>9.服务端把加密后的内容返回给客户端</p>
<p>10.客户端对使用密钥x对加密后的网页内容进行解密获取网页内容</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>跨站与跨域</title>
    <url>/2021/09/08/%E7%BD%91%E7%BB%9C-%E8%B7%A8%E5%9F%9F%E4%B8%8E%E8%B7%A8%E7%AB%99/</url>
    <content><![CDATA[<h4 id="跨站和跨域"><a href="#跨站和跨域" class="headerlink" title="跨站和跨域"></a>跨站和跨域</h4><p>他们有什么区别？<br>同站/跨站 和 第一方/第三方 是一样的<br>但是同站和浏览器的sop同源策略的概念完全不一样</p>
<h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>指两个 URL的协议  主机名  端口 三个都是一样的才是满足同源策略<br><a href="https://www.baidu.com/">https://www.baidu.com</a><br>协议: https<br>主机名: <a href="http://www.baidu.com/">www.baidu.com</a><br>端口: 443<br>同源策略是浏览器安全的基石，cookie的同站判断则没有这么严格<br>同站：只要两个域名的eTLD+1相同即可，不需要考虑协议和端口<br>eTLD表示顶级域名<br>eTLD+1表示 有效顶级域名+二级域名。 例如：baidu.com<br>.com  .cn  .github.io</p>
<h4 id="什么是跨站？"><a href="#什么是跨站？" class="headerlink" title="什么是跨站？"></a>什么是跨站？</h4><p>浏览器本身是允许cookie同站通信的；而所谓的“跨站”，比如cookie跨站实现第三方cookie，实际上就是想利用浏览器更加“开放”的那些规则来突破“同站”的限制。</p>
<h4 id="什么是CSRF跨站攻击？"><a href="#什么是CSRF跨站攻击？" class="headerlink" title="什么是CSRF跨站攻击？"></a>什么是CSRF跨站攻击？</h4><p>cookie往往是作为用户的标识信息，恶意网站通过携带正确的cookie信息发起HTTP请求，就是CSRF攻击。<br>比如：<br>用户返回了a.com这个网站，并携带了cookie，在浏览器中写入了cookie信息。</p>
<p>这时候某恶意网站b.com，上有个一个表单。<br>表单的action是a.com/api</p>
<p>这时如果用户在b.com上提交了表单，就会携带a.com网站的cookie信息。</p>
<p>为了防止这种攻击，表单一般会携带tooken信来标识该请求是真实请求。</p>
<p>这种三方网站引导发出的cookie，除了做恶意攻击还可以用作埋点统计，来统计用户访问了哪个网站。</p>
<p>samsite属性的作用<br>用来限制三方cookie，来减少安全风险。<br>1.strict<br>完全不允许跨站携带cookie<br>2.lax<br>规则稍稍放宽</p>
<p>链接<br>正常情况：允许发送<br>Lax：允许发送</p>
<p>预加载<br>正常情况：允许发送<br>Lax：允许发送</p>
<p>get表单<br>正常情况：允许发送<br>Lax：允许发送</p>
<p>post表单<br>正常情况：允许发送<br>Lax：不允许发送</p>
<p>ifram<br>正常情况：允许发送<br>Lax：不允许发送</p>
<p>ajax<br>正常情况：允许发送<br>Lax：不允许发送</p>
<p>image<br>正常情况：允许发送<br>Lax：不允许发送</p>
<p>3.none<br>浏览器将Lax设置为默认值<br>将值设置为None后必须设置secure属性（cookie必须同过https协议发送）</p>
<p>Set-Cookie: session=abc123; SameSite=None; Secure</p>
<p>防止CSRF跨站请求的方案。<br>一、通过校验Referer的值，确保请求时合法请求来源发起的请求。</p>
<p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory%EF%BC%8C%E7%94%A8%E6%88%B7%E5%BF%85%E9%A1%BB%E5%85%88%E7%99%BB%E9%99%86">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<pre><code>    这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。

    然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。
</code></pre>
<p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<p>2、通过添加token参数，服务端校验token来解决。</p>
<p>要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<pre><code>    这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 &lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。

     该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。
</code></pre>
<p>3.通过添加csrftoken参数的值token，服务端校验token来解决。</p>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex的使用方法和原理</title>
    <url>/2021/09/08/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Vuex%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue的加载顺序和渲染顺序</title>
    <url>/2021/09/08/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Vue%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%92%8C%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue的2和3版本的区别</title>
    <url>/2021/09/08/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Vue2%E5%92%8C3%E7%89%88%E6%9C%AC%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 的 nextTick</title>
    <url>/2021/09/08/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Vue-nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="nextTick是什么？"><a href="#nextTick是什么？" class="headerlink" title="nextTick是什么？"></a>nextTick是什么？</h2><p>nextTick是vue官方文档中的api，他可以在DOM更新完成后去执行一个回调函数。</p>
<p>虽然在mvvm框架中不推荐操作dom，但是在使用第三方插件时，免不了需要操作dom，nextTick可以确保我们操作的是更新过后的dom。</p>
<h2 id="如何检测Dom结构更新了？"><a href="#如何检测Dom结构更新了？" class="headerlink" title="如何检测Dom结构更新了？"></a>如何检测Dom结构更新了？</h2><p>MutationObserve</p>
<p>MutationObserve是H5新增的特性，用于监听dom结构发生的改变。能够监听到文本、属性、内容、子节点的变动。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserve(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;DOM发生了改变&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dom = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;article&#x27;</span>);</span><br><span class="line"></span><br><span class="line">observer.observer(dom);</span><br></pre></td></tr></table></figure>

<h2 id="vue如何实现nextTick"><a href="#vue如何实现nextTick" class="headerlink" title="vue如何实现nextTick"></a>vue如何实现nextTick</h2><p>源码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;shared/util&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">&#x27;./error&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">&#x27;./env&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)   <span class="comment">// setTimeout的最小时间延迟是4ms  所以放在最后</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为setTimeout的最小时间延迟是4ms  所以放在最后</p>
<p>如果多个watcher被多次出发也只会被加入到队列中一次</p>
<p>为什么在修改完之后立即获取Dom拿到的值还是修改前的？<br>因为vue更新dom的操作是异步的，并非同步，原因是为了避免频繁多次的触发watcher导致dom被频繁的更新而加大开销</p>
<p>在nextTick中做了两件事情<br>第一件事情是创建timerFun，把nextTick要执行的任务作为宏任务或者微任务加入到事件循环<br>第二件事吧回调函数放到一个callback队列中</p>
<p>当调用栈中的代码都执行完成时（dom的操作完成）<br>这个时候再去执行这个callBack，以达到在页面更新后<br>获取页面内容的目的</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue的computed和watch</title>
    <url>/2021/09/08/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-vue-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>compute是模版表达式的声明式描述，会创建新的响应式数据<br>watch是数据的监听器，用于响应数据变化。<br>compute具有缓存的功能，可依赖多个属性，getter无副作用的特点。<br>watch更适用于异步或开销大的操作。</p>
<h4 id="computed的实现"><a href="#computed的实现" class="headerlink" title="computed的实现"></a>computed的实现</h4><p>computed等同于给属性设置getter函数（也可设置setter）<br>而watch是为属性的setter设置回调函数、深度监听deep及响应速度immediate</p>
<p>1.初始化：为computed创建Lazy watcher<br>2.首次模版渲染：渲染watcher检测到computed属性时，会调用conputed的getter方法，而computed的getter方法会调用依赖属性的getter，形成链式的调用。同时会保存引用关系。取得计算结果后lazy watcher会将结果缓存，并返回渲染watcher进行模版渲染。</p>
<blockquote>
<p>这也是computed能缓存的原因，只要缓存的引用没更新，就不会进行重新进行计算</p>
</blockquote>
<p>3.多次模板渲染：直接获取lazy watcher的值进行渲染。<br>4.依赖属性更新：根据首次模版渲染阶段构建的依赖关系，通知lazy watcher进行重新计算，缓存计算结果并通知渲染watcher进行渲染。</p>
<h4 id="watch的原理"><a href="#watch的原理" class="headerlink" title="watch的原理"></a>watch的原理</h4><p>watch本质上就是为每个属性的setter添加watch监听。<br>当被监听的属性更新时，调用传入回调。<br>当watch配置deep时候，会对对象的每一个属性都增加watch。<br>当watch配置immediate时候，会在created的时候立即进行计算。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>computed：需要处理复杂模板逻辑表达式的时候<br>watch：需要执行异步，或者开销较大的操作。</p>
<blockquote>
<p>watch 的使用场景是可以覆盖computed的，但是我们在使用时尽量优先使用computed，如果computed无法满足再考虑watch，因为在相同的场景下，watch的代码量和所需要的开销都会比computed大。</p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue的双向数据绑定原理</title>
    <url>/2021/09/08/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="核心就是通过Object-defineProperty进行劫持-vue无法兼容IE8的原因"><a href="#核心就是通过Object-defineProperty进行劫持-vue无法兼容IE8的原因" class="headerlink" title="核心就是通过Object.defineProperty进行劫持 (vue无法兼容IE8的原因)"></a>核心就是通过Object.defineProperty进行劫持 (vue无法兼容IE8的原因)</h3><p>Object.defineProperty会直接在对象上定义一个新属性，或者修改对象的属性，修改后并返回该对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>,prop,descriptor);</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Object：定义属性对象的</span></span><br><span class="line"><span class="comment"> * prop：要定义或者修改的属性名称</span></span><br><span class="line"><span class="comment"> * descriptor： 将被定义或修改属性的描述符</span></span><br><span class="line"><span class="comment"> *** /</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>
<p>Object.defineProperty的使用示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">value</span>: <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&quot;value&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    text.innerHTML = val;</span><br><span class="line">    input.value = val;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实就在获取和操作对象的时候我们有了可以做额外操作的能力</p>
<p>还有就是要实现一个监听器Observer</p>
<p>Observer：数据的观察者，数据在进行读写操作的时候，都在Observer的监管下<br>Watcher：数据的订阅者，当Observer监听到数据变化的时候，会通知到watcher们，由watcher去做响应的操作（更新页面视图）<br>Dep：Observer和Watcher两者之间的纽带，他俩之间的沟通都会通过Dep来进行，Observer会先通知到Dep，再由dep去通知订阅者watcher</p>
<blockquote>
<p>Observer进行观察，dep被watcher订阅后，dep会把Observer观察到的通知到watcher</p>
</blockquote>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue2.0</span></span><br><span class="line"><span class="title">constructor</span> (<span class="params">value: any</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.value = value</span><br><span class="line">  <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">  def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">      ? protoAugment</span><br><span class="line">      : copyAugment</span><br><span class="line">    augment(value, arrayMethods, arrayKeys)</span><br><span class="line">    <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue3.0</span></span><br><span class="line">observer = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">  that.deps[key] = []; <span class="comment">//初始化所有订阅者对象&#123;msg: [订阅者], info: []&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> target[property];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> res = <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">   <span class="keyword">var</span> watchers = that.deps[key];</span><br><span class="line">   watchers.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item.update();</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">this</span>.$data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vue3的双向绑定原理与vue2的差不多 </span></span><br><span class="line"><span class="comment">// 他俩的区别是</span></span><br><span class="line"><span class="comment">// Object.defineProperty要一个一个属性定义set与get </span></span><br><span class="line"><span class="comment">// Proxy可以定义一个对象所有属性的get与set</span></span><br></pre></td></tr></table></figure>

<p>value就是被观察的对象，<br>在构造函数中value会被怎加__ob__属性，这就标识着value数据被监听了<br>如果value是数组：<br>会用observeArray方法遍历，对数组中的每一项都进行Observer的调用进行观察</p>
<p>如果value是对象：<br>会用walk方法进行遍历value对象的key，对每个key调用defineReactive来捕获key的set/get动作</p>
<h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h4><p>Dep可以认为是Observer的订阅系统，负责watcher的订阅<br>当observer观察到数据发生了改变的时候，会通过Dep去通知已订阅的订阅者</p>
<p>Dep有下面几个接口：</p>
<ul>
<li>addSub: 接收watcher的实例，并把实例进行记录存入数组种</li>
<li>removeSub: 从记录的数组中删除watcher的实例</li>
<li>depend: 要操作的实例存放在dep.target上，调用depend方法就会调用Watcher实例的addDep方法</li>
<li>notify: 通知订阅的watcher进行更新</li>
</ul>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vm：      vue组件的实例</span></span><br><span class="line"><span class="comment"> * expOrFn： 要订阅的数据字段或要执行的函数</span></span><br><span class="line"><span class="comment"> * cb：      watcher运行后要回调的函数</span></span><br><span class="line"><span class="comment"> * options： 选项对象，包含deep，user，lazy等配置</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="title">constructor</span> (<span class="params">vm, expOrFn, cb, options</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.vm = vm</span><br><span class="line">  vm._watchers.push(<span class="built_in">this</span>)</span><br><span class="line">  <span class="comment">// options</span></span><br><span class="line">  <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    <span class="built_in">this</span>.deep = !!options.deep</span><br><span class="line">    <span class="built_in">this</span>.user = !!options.user</span><br><span class="line">    <span class="built_in">this</span>.lazy = !!options.lazy</span><br><span class="line">    <span class="built_in">this</span>.sync = !!options.sync</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.deep = <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.cb = cb</span><br><span class="line">  <span class="built_in">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">  <span class="built_in">this</span>.active = <span class="literal">true</span></span><br><span class="line">  <span class="built_in">this</span>.dirty = <span class="built_in">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">  <span class="built_in">this</span>.deps = []</span><br><span class="line">  <span class="built_in">this</span>.newDeps = []</span><br><span class="line">  <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="built_in">this</span>.expression = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    ? expOrFn.toString()</span><br><span class="line">    : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.getter = expOrFn</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.getter) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">        <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy</span><br><span class="line">    ? <span class="literal">undefined</span></span><br><span class="line">    : <span class="built_in">this</span>.get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例中的方法如下：</p>
<ul>
<li>get: 将Dep.target设置为当前watcher实例，在内部调用this.getter，如果此时某个被Observer观察的数据对象被取值了，那么当前watcher实例将会自动订阅数据对象的Dep实例</li>
<li>addDep: 接收参数dep(Dep实例)，让当前watcher订阅dep</li>
<li>cleanupDeps: 清除newDepIds和newDep上记录的对dep的订阅信息</li>
<li>update: 立刻运行watcher或者将watcher加入队列中等待统一flush</li>
<li>run: 运行watcher，调用this.get()求值，然后触发回调</li>
<li>evaluate: 调用this.get()求值</li>
<li>depend: 遍历this.deps，让当前watcher实例订阅所有dep</li>
<li>teardown: 去除当前watcher实例所有的订阅</li>
</ul>
<blockquote>
<p>除了以上这些，vue还对数组的方法做了改造（push、pop、shift、unshift、sort、splice、reverse）<br>当调用数组的这些方法时会自动触发dep.notify()。来满足数组在调用方法修改后无法触发更新的问题</p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue的Diff算法</title>
    <url>/2021/09/08/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-vue-diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="VUE-的diff算法"><a href="#VUE-的diff算法" class="headerlink" title="VUE 的diff算法"></a>VUE 的diff算法</h1><p>什么是虚拟dom（virtual dom）<br>虚拟dom对应的是真实dom，通过createElement 和 createTexNode创建出来的都是真实dom，我通过以上两种方法创建出的dom对象，打印他们会发现会有很多属性，标准元素会实现出很多东西，如果每次都重新生成，会对资源产生很大的性能浪费。<br>virtual dom 就是通过一个简单的对象去代替复杂的dom对象，创建一个对象，对象上是dom的一些重要属性，在dom改变的时候，先比较虚拟dom的数据，如果需要改变，才会真正的去改变真实dom。<br>在优化dom的时候，相对简单的dom手动去处理是效率比较高的，但是如果是复杂的dom，嵌套比较深的，结构比较复杂的，手工去处理会花费很多时间，virtual dom不是最优的选择，但是在普适性，效率，可维护性之间达到了平衡。</p>
<p>虚拟dom的样子就像下面这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;v&quot;</span> <span class="attr">class</span>=<span class="string">&quot;classA&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>对应的 vnode 就是</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  el:  div  <span class="comment">//对真实的节点的引用，本例中就是document.querySelector(&#x27;#id.classA&#x27;)</span></span><br><span class="line">  tagName: &#x27;DIV&#x27;,   <span class="comment">//节点的标签</span></span><br><span class="line">  sel: &#x27;div#v.classA&#x27;  <span class="comment">//节点的选择器</span></span><br><span class="line">  data: <span class="literal">null</span>,       <span class="comment">// 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style</span></span><br><span class="line">  children: [], <span class="comment">//存储子节点的数组，每个子节点也是vnode结构</span></span><br><span class="line">  text: <span class="literal">null</span>,    <span class="comment">//如果是文本节点，对应文本节点的textContent，否则为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue diff算法的过程就是调用patch函数去给真实dom打补丁</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch函数有两个参数  分别是新旧的两个虚拟dom的节点</span><br></pre></td></tr></table></figure>
<h4 id="patch的第一部分是判断新旧两个节点是否值得比较"><a href="#patch的第一部分是判断新旧两个节点是否值得比较" class="headerlink" title="patch的第一部分是判断新旧两个节点是否值得比较"></a>patch的第一部分是判断新旧两个节点是否值得比较</h4><p>判断两个节点的key和sel（元素选择器 ） 是否都是相同的。如果是相同的才会去比较他们，<br>比如p和span不是同样的标签不会去比较，<br>div.classA和div.classB class类名不同 也会认为是不同结构而不去比较它们。<br>如果节点不值得比较则会进入到替换（当不值得比较时，新节点会直接把老节点整个替换）<br>获取就节点的el（真实的节点的引用）的父节点<br>通过createEle(vnode) 为新节点创建真实dom<br>然后吧parentEle把新的dom插入进去，移除旧节点的真实dom</p>
<p>然后会return vnode</p>
<p>patch方法执行的时候其实就是改变了vnode（新虚拟dom）的el的值<br>改变之前vnode.el = null;<br>改变之后vnode.el = 真实dom</p>
<h3 id="如果两个节点值得比较会调用pathVnode函数（重点⭐️）"><a href="#如果两个节点值得比较会调用pathVnode函数（重点⭐️）" class="headerlink" title="如果两个节点值得比较会调用pathVnode函数（重点⭐️）"></a>如果两个节点值得比较会调用pathVnode函数（重点⭐️）</h3><p>首先 const el = vnode.el = oldVnode.el;<br>让新节点的el引用到现在的真实dom，当el产生改变时候vnode（新的虚拟dom的节点）也会跟着一起变化。</p>
<p>节点比较的五种情况:<br>1.(oldVnode === vNode) 如果两个节点的引用一致，就认为是没有变化的直接就return 掉。<br>2.if(oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text)<br>文本节点的比较，需要修改，调用Node.textContent = vnode.text修改文本内容。<br>3.if( oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch ), 两个节点都有子节点，而且它们不一样，这样我们会调用updateChildren函数比较子节点⭐️。<br>4.else if (ch)，只有新的节点有子节点，调用createEle(vnode)，vnode.el已经引用了老的dom节点，createEle函数会在老dom节点上添加子节点。<br>5.else if (oldCh)，新节点没有子节点，老节点有子节点，就删除老节点。</p>
<h3 id="如果两个节点值得比较会调用pathVnode函数（重点⭐️）-1"><a href="#如果两个节点值得比较会调用pathVnode函数（重点⭐️）-1" class="headerlink" title="如果两个节点值得比较会调用pathVnode函数（重点⭐️）"></a>如果两个节点值得比较会调用pathVnode函数（重点⭐️）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updateChildren (parentElm, oldCh, newCh) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx</span><br><span class="line">    <span class="keyword">let</span> idxInOld</span><br><span class="line">    <span class="keyword">let</span> elmToMove</span><br><span class="line">    <span class="keyword">let</span> before</span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;   <span class="comment">//对于vnode.key的比较，会把oldVnode = null</span></span><br><span class="line">                oldStartVnode = oldCh[++oldStartIdx] </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">                oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">                newEndVnode = newCh[--newEndIdx]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">                patchVnode(oldStartVnode, newStartVnode)</span><br><span class="line">                oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">                patchVnode(oldEndVnode, newEndVnode)</span><br><span class="line">                oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">                newEndVnode = newCh[--newEndIdx]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">                patchVnode(oldStartVnode, newEndVnode)</span><br><span class="line">                api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))</span><br><span class="line">                oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">                newEndVnode = newCh[--newEndIdx]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">                patchVnode(oldEndVnode, newStartVnode)</span><br><span class="line">                api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)</span><br><span class="line">                oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 使用key时的比较</span></span><br><span class="line">                <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) <span class="comment">// 有key生成index表</span></span><br><span class="line">                &#125;</span><br><span class="line">                idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">                <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                    newStartVnode = newCh[++newStartIdx]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    elmToMove = oldCh[idxInOld]</span><br><span class="line">                    <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">                        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        patchVnode(elmToMove, newStartVnode)</span><br><span class="line">                        oldCh[idxInOld] = <span class="literal">null</span></span><br><span class="line">                        api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)</span><br><span class="line">                    &#125;</span><br><span class="line">                    newStartVnode = newCh[++newStartIdx]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">            before = newCh[newEndIdx + <span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].el</span><br><span class="line">            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>oldch 和 newch各有两个头尾的变量StartIdx和EndIdx，他们两个变量会互作比较，总共有四种比较方式，<br>如果四种比较都没匹配上，如果设置了key就会用key进行比较，在比较的过程中，变量会向中间靠，一旦startIdx&gt;endIdx表明oldCh或者newCh有一个已经遍历完成，就会有比较的结果。</p>
<h2 id="具体的diff分析"><a href="#具体的diff分析" class="headerlink" title="具体的diff分析"></a>具体的diff分析</h2><h3 id="设置key和不设置key有什么区别？"><a href="#设置key和不设置key有什么区别？" class="headerlink" title="设置key和不设置key有什么区别？"></a>设置key和不设置key有什么区别？</h3><p>不设置key只会进行头尾两端相互比较，<br>设置key了之后除了头尾两端比较，还会用生成的key去生成的对象oldKeyToIndex中查找匹配节点，所以节点设置key可以更高效的利用dom。<br>1.key的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。另外，某些情况下不带key可能性能更好<br>2.组件复用可能会导致状态保留，修改其中一个导致全部都变，使用key，更新时会找到对应的组件，以确保正确。</p>
<p>不用 key：<br>就地复用节点。在比较新旧两个节点是否是同一个节点的过程中会判断成新旧两个节点是同一个节点，因为 a.key 和 b.key 都是 undefined。所以不会重新创建节点和删除节点，只会在节点的属性层面上进行比较和更新。所以可能在某种程度上（创建和删除节点方面）会有渲染性能上的提升；</p>
<p>无法维持组件的状态。由于就地复用节点的关系，可能在维持组件状态方面会导致不可预知的错误，比如无法维持改组件的动画效果、开关等状态；</p>
<p>也有可能会带来性能下降。因为是直接就地复用节点，如果修改的组件，需要复用的很多节点，顺序又和原来的完全不同的话，那么创建和删除的节点数量就会比带 key 的时候增加很多，性能就会有所下降；</p>
<p>用 key：<br>维持组件的状态，保证组件的复用。因为有 key 唯一标识了组件，不会在每次比较新旧两个节点是否是同一个节点的时候直接判断为同一个节点，而是会继续在接下来的节点中找到 key 相同的节点去比较，能找到相同的 key 的话就复用节点，不能找到的话就增加或者删除节点。</p>
<p>查找性能上的提升。有 key 的时候，会生成 hash，这样在查找的时候就是 hash 查找了，基本上就是 O(1) 的复杂度。</p>
<p>节点复用带来的性能提升。因为有 key 唯一标识了组件，所以会尽可能多的对组件进行复用（尽管组件顺序不同），那么创建和删除节点数量就会变少，这方面的消耗就会下降，带来性能的提升。</p>
<blockquote>
<p>总结：性能提升不能只考虑一方面，不是 diff 快了性能就快，不是增删节点少了性能就快，不考虑量级的去评价性能，都只是泛泛而谈。</p>
</blockquote>
<blockquote>
<p>说明：以上描述的「节点」和「组件」其实是同一个东西，只是表达上不同而已。</p>
</blockquote>
<p>在遍历过程中对dom操作主要是调用insertBefor</p>
<p>对于sameVnode(oldStartVnode, newStartVnode)和sameVnode(oldEndVnode,newEndVnode)为true的情况，不需要对dom进行移动位置。</p>
<p>在便利的过程中，有3种dom操作。</p>
<p>1.当oldStartVnode和newEndVnode 值得比较时，oldStartVnode.el就会到oldEndVnode.el的后面。<br>2.当oldEndVnode和newStartVnode 值得比较时，oldEndVnode.el就会到oldStartVnode.el的前面。<br>3.当newStartVnode在所有的oldEndVnode中找不到时，也就是newCh里的节点在oldCh中没有，会将节点插入到oldEndVnode.el的前面。（parentElement.insertBefore(newElement, referenceElement)）</p>
<p>如果referenceElement为null则把新节点插入到子节点的末尾处。<br>如果newElement已经存在DOM树中，newElement首先会从DOM树中移除。 所以before为null，newElement将会被插在末尾处。</p>
<p>在结束的时候，会有两种情况：<br>1.oldStartIdx&gt;oldEndIdx表示oldCh先遍历完成，或者这个时候newCh也刚好遍历完成。<br>这个时候newStartIdx和newEndIdx之间的vnode都是新增的vnode，调用addVnodes,把这些节点通过insertBefor的方法全部插入到before的后面。</p>
<p>2.newStartIdx&gt;newEndIdx,表示newCh是先遍历完成的。这时oldStartIdx和oldEndIdx之间的vnode在新的节点中已经是不存在了，就会调用removeVnodes方法将他们从dom中删除。</p>
<h3 id="Diff算法-的时间复杂度为-O-n-3"><a href="#Diff算法-的时间复杂度为-O-n-3" class="headerlink" title="Diff算法 的时间复杂度为 O(n^3)"></a>Diff算法 的时间复杂度为 O(n^3)</h3><h3 id="将两个DOM树的所有节点两两对比，时间复杂度-O-n-2"><a href="#将两个DOM树的所有节点两两对比，时间复杂度-O-n-2" class="headerlink" title="将两个DOM树的所有节点两两对比，时间复杂度 O(n^2)"></a>将两个DOM树的所有节点两两对比，时间复杂度 O(n^2)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      prev                    last   </span><br><span class="line"></span><br><span class="line">       A                        A</span><br><span class="line">     /   \                    /   \</span><br><span class="line">    D     B       =&gt;         B     D</span><br><span class="line">  /                                  \</span><br><span class="line">C                                     C</span><br></pre></td></tr></table></figure>
<p>  所有节点两两相互对比：<br>  pA =&gt; lA<br>  pA =&gt; lB<br>  pA =&gt; lD<br>  pA =&gt; lC<br>  …<br>  pC =&gt; lC</p>
<p>再进行树的编辑(插入、替换、删除)需要遍历一次，因此时间复杂度为 O(n^3)</p>
<h3 id="React和vue-Diff算法-时间复杂度都是-gt-O-n-gt-简单粗暴，所有的节点按层级比较，只会遍历一次"><a href="#React和vue-Diff算法-时间复杂度都是-gt-O-n-gt-简单粗暴，所有的节点按层级比较，只会遍历一次" class="headerlink" title="React和vue Diff算法 时间复杂度都是 =&gt; O(n) =&gt; 简单粗暴，所有的节点按层级比较，只会遍历一次"></a>React和vue Diff算法 时间复杂度都是 =&gt; O(n) =&gt; 简单粗暴，所有的节点按层级比较，只会遍历一次</h3><p> # 按叶子节点位置比较<br> [0,0]              :  pA =&gt; lA      #相同，不理会<br> [0.0,0.0]        :  pD =&gt; lB      #不同，删除pD，添加lB<br> [0.1,0.1]        :  pB =&gt; lD      #不同，删除pB，添加lD<br> [0.1.0,0.1.0]  :  pC =&gt; Null   #last树没有该节点，直接删除pC<br> [0.1.2,0.1.2]  :  Null =&gt; lC    #prev树没有该节点，添加lC到该位置
 </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>前端模块化发展历程</title>
    <url>/2021/09/08/%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><p>前端模块化主要作用是用来抽离公共代码，隔离作用域，避免变量冲突。</p>
<h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>使用自执行函数来划分代码模块。<br>特点：在一个单独的函数作用域中之行代码，避免变量的冲突。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="title">fucntion</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">dataArr</span>:[]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>只在浏览器中实现，使用require.js<br>特点：依赖必须提前声明好；加载为异步加载，指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>,<span class="string">&#x27;module2&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">define(<span class="string">&#x27;./index.js&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>在Nodejs中可以使用，在浏览器有webpack，browserfy</p>
<p>特点：<br>模块加载同步，资源加载完成后再执行代码<br>每个文件都可以是一个模块<br>服务端：模块加载是在运行时同步加载<br>浏览器：模块加载是提前编译打包处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入三方</span></span><br><span class="line"><span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;module1.js&#x27;</span>)</span><br><span class="line"><span class="comment">//引入自定义模块</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./../aaa.jpg&#x27;</span>)</span><br><span class="line"><span class="comment">//读入文件，并返回模块export的对象。如果没有找到指定模块，代码会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对外暴漏的方法</span></span><br><span class="line"><span class="built_in">module</span>.export = value</span><br><span class="line"><span class="keyword">export</span>.xx = value</span><br><span class="line"><span class="comment">//module变量代表当前模块，export属性是对外的接口</span></span><br></pre></td></tr></table></figure>

<h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>是AMD和CommonJS（服务端模块化规范)的结合体，保证模块可以被amd和commonjs调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Root 想要挂载的位置</span></span><br><span class="line"><span class="comment">//factory 对应的真实模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">Root,factory</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tyepOf define ===<span class="string">&#x27;fucntion&#x27;</span> &amp;&amp; define.amd)&#123;<span class="comment">//兼容AMD</span></span><br><span class="line">    define(<span class="string">&#x27;./index.js&#x27;</span>,factory)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tyepOf <span class="built_in">exports</span> === <span class="string">&#x27;Object&#x27;</span> &amp;&amp; <span class="built_in">module</span>.exports)&#123;<span class="comment">//兼容commonjs</span></span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"> root, moduleA </span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> ( moduleA === <span class="literal">undefined</span> ) &#123;</span><br><span class="line">              <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> ) &#123;</span><br><span class="line">                  moduleA = <span class="built_in">require</span>(<span class="string">&#x27;./index.js&#x27;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  moduleA = <span class="built_in">require</span>(<span class="string">&#x27;./index.js&#x27;</span>)(root);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          factory(moduleA);</span><br><span class="line">          <span class="keyword">return</span> moduleA;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    factory(moduleA)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span></span>)</span>&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>只在浏览器实现，使用sea.js<br>特点：<br>整合了commonjs和AMD的特点<br>模块使用时再声明<br>模块的加载是异步的，在使用模块的时候才会加载执行。使用是同步的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步加载</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> =<span class="built_in">require</span>(<span class="string">&#x27;module1.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步加载</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;module2.js&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//使用module</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对外暴露</span></span><br><span class="line"> <span class="built_in">module</span>.export = value</span><br><span class="line"> <span class="keyword">export</span>.xx = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入其他模块后再对外暴露</span></span><br><span class="line"><span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2.js&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./module2.js&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span>.xx = module2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="es6-module"><a href="#es6-module" class="headerlink" title="es6 module"></a>es6 module</h3><p>服务端和浏览器都可以进行使用</p>
<p>特点：<br>需要babel将es6转为es5<br>browserify编译<br>依赖需要提前声明在顶层</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// impport  </span></span><br><span class="line"><span class="comment">// export M    export default M</span></span><br></pre></td></tr></table></figure>




<h2 id="es6-module-和-commonjs的区别"><a href="#es6-module-和-commonjs的区别" class="headerlink" title="es6 module 和 commonjs的区别"></a>es6 module 和 commonjs的区别</h2><p>1.使用<br>es6模块是动态引用，不会缓存值，模块里的变量属于模块。<br>common加载的是一个值的copy，模块可以多次加载，但是只会在第一次运行时加载，以后再次加载，只会读取第一次加载的缓存值，如果想重新加载，就要清除缓存。</p>
<p>2.加载<br>es6 module 模块不是对象，只是一种对外的静态定义，在代码静态解析阶段就会生成。</p>
<p>common是在运行时加载。</p>
<p><img src="./../assets/images/webpack.png" alt="webpack 图标"></p>
<p>相关链接:<br><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28#issuecomment-470043656">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28#issuecomment-470043656</a></p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/2021/09/14/JavaScript-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h4 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h4><p>垃圾回收也被称为GC（Garbage Collection）<br>他是一种内存的自动管理机制。<br>可以自动回收分配给程序的已经不再使用的内存，常见的垃圾回收的算法有引用计数法，和标记清楚法等。<br>V8的垃圾回收算法是由Mark-Compact和Scavenger构成</p>
<h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><p>指应当被回收的对象没有被回收，变成常驻老生代的对象，导致内存占用越来越高，内存泄漏会导致应用程序速度变慢，高延迟，甚至会导致程序崩溃。</p>
<p>内存的生命周期：分配 -&gt; 使用 -&gt; 释放</p>
<p>内存泄漏的原因：<br>1.创建全局变量，没有手动回收<br>2.事件监听，定时器，闭包，未被正常清理</p>
<h4 id="Reference-Counting（引用计数）算法"><a href="#Reference-Counting（引用计数）算法" class="headerlink" title="Reference Counting（引用计数）算法"></a>Reference Counting（引用计数）算法</h4><p>核心思路就是记录资源的引用次数，当引用次数为0时，就会被清除释放。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line">  .then(fucntion (res)&#123;</span><br><span class="line">    <span class="comment">//如果这样写这里的this会指向什么地方</span></span><br><span class="line">  &#125;)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>576 61</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
  </entry>
</search>
